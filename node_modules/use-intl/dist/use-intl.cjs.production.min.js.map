{"version":3,"file":"use-intl.cjs.production.min.js","sources":["../src/IntlContext.tsx","../src/IntlError.tsx","../src/IntlProvider.tsx","../src/convertFormatsToIntlMessageFormat.tsx","../src/useIntlContext.tsx","../src/useTranslations.tsx","../src/useNow.tsx","../src/useIntl.tsx","../src/useLocale.tsx","../src/useTimeZone.tsx"],"sourcesContent":["import {createContext} from 'react';\nimport Formats from './Formats';\nimport IntlError from './IntlError';\nimport IntlMessages from './IntlMessages';\n\nexport type IntlContextShape = {\n  messages?: IntlMessages;\n  locale: string;\n  formats?: Partial<Formats>;\n  timeZone?: string;\n  onError(error: IntlError): void;\n  getMessageFallback(info: {\n    error: IntlError;\n    key: string;\n    namespace?: string;\n  }): string;\n  now?: Date;\n};\n\nconst IntlContext = createContext<IntlContextShape | undefined>(undefined);\n\nexport default IntlContext;\n","export enum IntlErrorCode {\n  MISSING_MESSAGE = 'MISSING_MESSAGE',\n  MISSING_FORMAT = 'MISSING_FORMAT',\n  INSUFFICIENT_PATH = 'INSUFFICIENT_PATH',\n  INVALID_MESSAGE = 'INVALID_MESSAGE',\n  FORMATTING_ERROR = 'FORMATTING_ERROR'\n}\n\nexport default class IntlError extends Error {\n  public readonly code: IntlErrorCode;\n  public readonly originalMessage: string | undefined;\n\n  constructor(code: IntlErrorCode, originalMessage?: string) {\n    let message: string = code;\n    if (originalMessage) {\n      message += ': ' + originalMessage;\n    }\n    super(message);\n\n    this.code = code;\n    if (originalMessage) {\n      this.originalMessage = originalMessage;\n    }\n  }\n}\n","import React, {ReactNode} from 'react';\nimport Formats from './Formats';\nimport IntlContext from './IntlContext';\nimport IntlMessages from './IntlMessages';\nimport {IntlError} from '.';\n\ntype Props = {\n  /** All messages that will be available in your components. */\n  messages?: IntlMessages;\n  /** A valid Unicode locale tag (e.g. \"en\" or \"en-GB\"). */\n  locale: string;\n  /** Global formats can be provided to achieve consistent\n   * formatting across components. */\n  formats?: Partial<Formats>;\n  /** A time zone as defined in [the tz database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones) which will be applied when formatting dates and times. If this is absent, the user time zone will be used. You can override this by supplying an explicit time zone to `formatDateTime`. */\n  timeZone?: string;\n  /** This callback will be invoked when an error is encountered during\n   * resolving a message or formatting it. This defaults to `console.error` to\n   * keep your app running. You can customize the handling by taking\n   * `error.code` into account. */\n  onError?(error: IntlError): void;\n  /** Will be called when a message couldn't be resolved or formatting it led to\n   * an error. This defaults to `${namespace}.${key}` You can use this to\n   * customize what will be rendered in this case. */\n  getMessageFallback?(info: {\n    namespace?: string;\n    key: string;\n    error: IntlError;\n  }): string;\n  /** All components that use the provided hooks should be within this tree. */\n  children: ReactNode;\n  /**\n   * Providing this value will have two effects:\n   * 1. It will be used as the default for the `now` argument of\n   *    `useIntl().formatRelativeTime` if no explicit value is provided.\n   * 2. It will be returned as a static value from the `useNow` hook. Note\n   *    however that when `updateInterval` is configured on the `useNow` hook,\n   *    the global `now` value will only be used for the initial render, but\n   *    afterwards the current date will be returned continuously.\n   */\n  now?: Date;\n};\n\nfunction defaultGetMessageFallback({\n  key,\n  namespace\n}: {\n  key: string;\n  namespace?: string;\n}) {\n  return [namespace, key].filter((part) => part != null).join('.');\n}\n\nfunction defaultOnError(error: IntlError) {\n  console.error(error);\n}\n\nexport default function IntlProvider({\n  children,\n  onError = defaultOnError,\n  getMessageFallback = defaultGetMessageFallback,\n  ...contextValues\n}: Props) {\n  return (\n    <IntlContext.Provider\n      value={{...contextValues, onError, getMessageFallback}}\n    >\n      {children}\n    </IntlContext.Provider>\n  );\n}\n","import {Formats as IntlFormats} from 'intl-messageformat';\nimport DateTimeFormatOptions from './DateTimeFormatOptions';\nimport Formats from './Formats';\n\nfunction setTimeZoneInFormats(\n  formats: Record<string, DateTimeFormatOptions> | undefined,\n  timeZone: string\n) {\n  if (!formats) return formats;\n\n  // The only way to set a time zone with `intl-messageformat` is to merge it into the formats\n  // https://github.com/formatjs/formatjs/blob/8256c5271505cf2606e48e3c97ecdd16ede4f1b5/packages/intl/src/message.ts#L15\n  return Object.keys(formats).reduce(\n    (acc: Record<string, DateTimeFormatOptions>, key) => {\n      acc[key] = {\n        timeZone,\n        ...formats[key]\n      };\n      return acc;\n    },\n    {}\n  );\n}\n\n/**\n * `intl-messageformat` uses separate keys for `date` and `time`, but there's\n * only one native API: `Intl.DateTimeFormat`. Additionally you might want to\n * include both a time and a date in a value, therefore the separation doesn't\n * seem so useful. We offer a single `dateTime` namespace instead, but we have\n * to convert the format before `intl-messageformat` can be used.\n */\nexport default function convertFormatsToIntlMessageFormat(\n  formats: Partial<Formats>,\n  timeZone?: string\n): Partial<IntlFormats> {\n  const formatsWithTimeZone = timeZone\n    ? {...formats, dateTime: setTimeZoneInFormats(formats.dateTime, timeZone)}\n    : formats;\n\n  return {\n    ...formatsWithTimeZone,\n    date: formatsWithTimeZone?.dateTime,\n    time: formatsWithTimeZone?.dateTime\n  };\n}\n","import {useContext} from 'react';\nimport IntlContext from './IntlContext';\n\nexport default function useIntlContext() {\n  const context = useContext(IntlContext);\n\n  if (!context) {\n    throw new Error(\n      __DEV__\n        ? 'No intl context found. Have you configured the provider?'\n        : undefined\n    );\n  }\n\n  return context;\n}\n","import IntlMessageFormat from 'intl-messageformat';\nimport {\n  cloneElement,\n  isValidElement,\n  ReactElement,\n  ReactNode,\n  ReactNodeArray,\n  useMemo,\n  useRef\n} from 'react';\nimport Formats from './Formats';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport IntlMessages from './IntlMessages';\nimport TranslationValues, {RichTranslationValues} from './TranslationValues';\nimport convertFormatsToIntlMessageFormat from './convertFormatsToIntlMessageFormat';\nimport useIntlContext from './useIntlContext';\n\nfunction resolvePath(\n  messages: IntlMessages | undefined,\n  idPath: string,\n  namespace?: string\n) {\n  if (!messages) {\n    throw new Error(\n      __DEV__ ? `No messages available at \\`${namespace}\\`.` : undefined\n    );\n  }\n\n  let message = messages;\n\n  idPath.split('.').forEach((part) => {\n    const next = (message as any)[part];\n\n    if (part == null || next == null) {\n      throw new Error(\n        __DEV__\n          ? `Could not resolve \\`${idPath}\\` in ${\n              namespace ? `\\`${namespace}\\`` : 'messages'\n            }.`\n          : undefined\n      );\n    }\n\n    message = next;\n  });\n\n  return message;\n}\n\nfunction prepareTranslationValues(values?: RichTranslationValues) {\n  if (!values) return values;\n\n  // Workaround for https://github.com/formatjs/formatjs/issues/1467\n  const transformedValues: RichTranslationValues = {};\n  Object.keys(values).forEach((key) => {\n    const value = values[key];\n\n    let transformed;\n    if (typeof value === 'function') {\n      transformed = (children: ReactNode) => {\n        const result = value(children);\n\n        return isValidElement(result)\n          ? cloneElement(result, {\n              key: result.key || key + String(children)\n            })\n          : result;\n      };\n    } else {\n      transformed = value;\n    }\n\n    transformedValues[key] = transformed;\n  });\n\n  return transformedValues;\n}\n\n/**\n * Translates messages from the given namespace by using the ICU syntax.\n * See https://formatjs.io/docs/core-concepts/icu-syntax.\n *\n * If no namespace is provided, all available messages are returned.\n * The namespace can also indicate nesting by using a dot\n * (e.g. `namespace.Component`).\n */\nexport default function useTranslations(namespace?: string) {\n  const {\n    formats: globalFormats,\n    getMessageFallback,\n    locale,\n    messages: allMessages,\n    onError,\n    timeZone\n  } = useIntlContext();\n\n  const cachedFormatsByLocaleRef = useRef<\n    Record<string, Record<string, IntlMessageFormat>>\n  >({});\n\n  const messagesOrError = useMemo(() => {\n    try {\n      if (!allMessages) {\n        throw new Error(\n          __DEV__ ? `No messages were configured on the provider.` : undefined\n        );\n      }\n\n      const retrievedMessages = namespace\n        ? resolvePath(allMessages, namespace)\n        : allMessages;\n\n      if (!retrievedMessages) {\n        throw new Error(\n          __DEV__\n            ? `No messages for namespace \\`${namespace}\\` found.`\n            : undefined\n        );\n      }\n\n      return retrievedMessages;\n    } catch (error) {\n      const intlError = new IntlError(\n        IntlErrorCode.MISSING_MESSAGE,\n        (error as Error).message\n      );\n      onError(intlError);\n      return intlError;\n    }\n  }, [allMessages, namespace, onError]);\n\n  const translate = useMemo(() => {\n    function getFallbackFromErrorAndNotify(\n      key: string,\n      code: IntlErrorCode,\n      message?: string\n    ) {\n      const error = new IntlError(code, message);\n      onError(error);\n      return getMessageFallback({error, key, namespace});\n    }\n\n    function translateBaseFn(\n      /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n      key: string,\n      /** Key value pairs for values to interpolate into the message. */\n      values?: RichTranslationValues,\n      /** Provide custom formats for numbers, dates and times. */\n      formats?: Partial<Formats>\n    ): string | ReactElement | ReactNodeArray {\n      const cachedFormatsByLocale = cachedFormatsByLocaleRef.current;\n\n      if (messagesOrError instanceof IntlError) {\n        // We have already warned about this during render\n        return getMessageFallback({\n          error: messagesOrError,\n          key,\n          namespace\n        });\n      }\n      const messages = messagesOrError;\n\n      const cacheKey = [namespace, key]\n        .filter((part) => part != null)\n        .join('.');\n\n      let messageFormat;\n      if (cachedFormatsByLocale[locale]?.[cacheKey]) {\n        messageFormat = cachedFormatsByLocale[locale][cacheKey];\n      } else {\n        let message;\n        try {\n          message = resolvePath(messages, key, namespace);\n        } catch (error) {\n          return getFallbackFromErrorAndNotify(\n            key,\n            IntlErrorCode.MISSING_MESSAGE,\n            (error as Error).message\n          );\n        }\n\n        if (typeof message === 'object') {\n          return getFallbackFromErrorAndNotify(\n            key,\n            IntlErrorCode.INSUFFICIENT_PATH,\n            __DEV__\n              ? `Insufficient path specified for \\`${key}\\` in \\`${\n                  namespace ? `\\`${namespace}\\`` : 'messages'\n                }\\`.`\n              : undefined\n          );\n        }\n\n        try {\n          messageFormat = new IntlMessageFormat(\n            message,\n            locale,\n            convertFormatsToIntlMessageFormat(\n              {...globalFormats, ...formats},\n              timeZone\n            )\n          );\n        } catch (error) {\n          return getFallbackFromErrorAndNotify(\n            key,\n            IntlErrorCode.INVALID_MESSAGE,\n            (error as Error).message\n          );\n        }\n\n        if (!cachedFormatsByLocale[locale]) {\n          cachedFormatsByLocale[locale] = {};\n        }\n        cachedFormatsByLocale[locale][cacheKey] = messageFormat;\n      }\n\n      try {\n        const formattedMessage = messageFormat.format(\n          prepareTranslationValues(values)\n        );\n\n        if (formattedMessage == null) {\n          throw new Error(\n            __DEV__\n              ? `Unable to format \\`${key}\\` in ${\n                  namespace ? `namespace \\`${namespace}\\`` : 'messages'\n                }`\n              : undefined\n          );\n        }\n\n        // Limit the function signature to return strings or React elements\n        return isValidElement(formattedMessage) ||\n          // Arrays of React elements\n          Array.isArray(formattedMessage) ||\n          typeof formattedMessage === 'string'\n          ? formattedMessage\n          : String(formattedMessage);\n      } catch (error) {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.FORMATTING_ERROR,\n          (error as Error).message\n        );\n      }\n    }\n\n    function translateFn(\n      /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n      key: string,\n      /** Key value pairs for values to interpolate into the message. */\n      values?: TranslationValues,\n      /** Provide custom formats for numbers, dates and times. */\n      formats?: Partial<Formats>\n    ): string {\n      const message = translateBaseFn(key, values, formats);\n\n      if (typeof message !== 'string') {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.INVALID_MESSAGE,\n          __DEV__\n            ? `The message \\`${key}\\` in ${\n                namespace ? `namespace \\`${namespace}\\`` : 'messages'\n              } didn't resolve to a string. If you want to format rich text, use \\`t.rich\\` instead.`\n            : undefined\n        );\n      }\n\n      return message;\n    }\n\n    translateFn.rich = translateBaseFn;\n\n    translateFn.raw = (\n      /** Use a dot to indicate a level of nesting (e.g. `namespace.nestedLabel`). */\n      key: string\n    ): any => {\n      if (messagesOrError instanceof IntlError) {\n        // We have already warned about this during render\n        return getMessageFallback({\n          error: messagesOrError,\n          key,\n          namespace\n        });\n      }\n      const messages = messagesOrError;\n\n      try {\n        return resolvePath(messages, key, namespace);\n      } catch (error) {\n        return getFallbackFromErrorAndNotify(\n          key,\n          IntlErrorCode.MISSING_MESSAGE,\n          (error as Error).message\n        );\n      }\n    };\n\n    return translateFn;\n  }, [\n    getMessageFallback,\n    globalFormats,\n    locale,\n    messagesOrError,\n    namespace,\n    onError,\n    timeZone\n  ]);\n\n  return translate;\n}\n","import {useState, useEffect} from 'react';\nimport useIntlContext from './useIntlContext';\n\ntype Options = {\n  updateInterval?: number;\n};\n\nfunction getNow() {\n  return new Date();\n}\n\n/**\n * Reading the current date via `new Date()` in components should be avoided, as\n * it causes components to be impure and can lead to flaky tests. Instead, this\n * hook can be used.\n *\n * By default, it returns the time when the component mounts. If `updateInterval`\n * is specified, the value will be updated based on the interval.\n *\n * You can however also return a static value from this hook, if you\n * configure the `now` parameter on the context provider. Note however,\n * that if `updateInterval` is configured in this case, the component\n * will initialize with the global value, but will afterwards update\n * continuously based on the interval.\n *\n * For unit tests, this can be mocked to a constant value. For end-to-end\n * testing, an environment parameter can be passed to the `now` parameter\n * of the provider to mock this to a static value.\n */\nexport default function useNow(options?: Options) {\n  const updateInterval = options?.updateInterval;\n\n  const {now: globalNow} = useIntlContext();\n  const [now, setNow] = useState(globalNow || getNow());\n\n  useEffect(() => {\n    if (!updateInterval) return;\n\n    const intervalId = setInterval(() => {\n      setNow(getNow());\n    }, updateInterval);\n\n    return () => {\n      clearInterval(intervalId);\n    };\n  }, [globalNow, updateInterval]);\n\n  return now;\n}\n","import DateTimeFormatOptions from './DateTimeFormatOptions';\nimport IntlError, {IntlErrorCode} from './IntlError';\nimport useIntlContext from './useIntlContext';\n\nconst MINUTE = 60;\nconst HOUR = MINUTE * 60;\nconst DAY = HOUR * 24;\nconst WEEK = DAY * 7;\nconst MONTH = DAY * (365 / 12); // Approximation\nconst YEAR = DAY * 365;\n\nfunction getRelativeTimeFormatConfig(seconds: number) {\n  const absValue = Math.abs(seconds);\n  let value, unit: Intl.RelativeTimeFormatUnit;\n\n  // We have to round the resulting values, as `Intl.RelativeTimeFormat`\n  // will include fractions like '2.1 hours ago'.\n\n  if (absValue < MINUTE) {\n    unit = 'second';\n    value = Math.round(seconds);\n  } else if (absValue < HOUR) {\n    unit = 'minute';\n    value = Math.round(seconds / MINUTE);\n  } else if (absValue < DAY) {\n    unit = 'hour';\n    value = Math.round(seconds / HOUR);\n  } else if (absValue < WEEK) {\n    unit = 'day';\n    value = Math.round(seconds / DAY);\n  } else if (absValue < MONTH) {\n    unit = 'week';\n    value = Math.round(seconds / WEEK);\n  } else if (absValue < YEAR) {\n    unit = 'month';\n    value = Math.round(seconds / MONTH);\n  } else {\n    unit = 'year';\n    value = Math.round(seconds / YEAR);\n  }\n\n  return {value, unit};\n}\n\nexport default function useIntl() {\n  const {formats, locale, now: globalNow, onError, timeZone} = useIntlContext();\n\n  function resolveFormatOrOptions<Options>(\n    typeFormats: Record<string, Options> | undefined,\n    formatOrOptions?: string | Options\n  ) {\n    let options;\n    if (typeof formatOrOptions === 'string') {\n      const formatName = formatOrOptions;\n      options = typeFormats?.[formatName];\n\n      if (!options) {\n        const error = new IntlError(\n          IntlErrorCode.MISSING_FORMAT,\n          __DEV__\n            ? `Format \\`${formatName}\\` is not available. You can configure it on the provider or provide custom options.`\n            : undefined\n        );\n        onError(error);\n        throw error;\n      }\n    } else {\n      options = formatOrOptions;\n    }\n\n    return options;\n  }\n\n  function getFormattedValue<Value, Options>(\n    value: Value,\n    formatOrOptions: string | Options | undefined,\n    typeFormats: Record<string, Options> | undefined,\n    formatter: (options?: Options) => string\n  ) {\n    let options;\n    try {\n      options = resolveFormatOrOptions(typeFormats, formatOrOptions);\n    } catch (error) {\n      return String(value);\n    }\n\n    try {\n      return formatter(options);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(value);\n    }\n  }\n\n  function formatDateTime(\n    /** If a number is supplied, this is interpreted as a UTC timestamp. */\n    value: Date | number,\n    /** If a time zone is supplied, the `value` is converted to that time zone.\n     * Otherwise the user time zone will be used. */\n    formatOrOptions?: string | DateTimeFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.dateTime,\n      (options) => {\n        if (timeZone && !options?.timeZone) {\n          options = {...options, timeZone};\n        }\n\n        return new Intl.DateTimeFormat(locale, options).format(value);\n      }\n    );\n  }\n\n  function formatNumber(\n    value: number,\n    formatOrOptions?: string | Intl.NumberFormatOptions\n  ) {\n    return getFormattedValue(\n      value,\n      formatOrOptions,\n      formats?.number,\n      (options) => new Intl.NumberFormat(locale, options).format(value)\n    );\n  }\n\n  function formatRelativeTime(\n    /** The date time that needs to be formatted. */\n    date: number | Date,\n    /** The reference point in time to which `date` will be formatted in relation to.  */\n    now?: number | Date\n  ) {\n    try {\n      if (!now) {\n        if (globalNow) {\n          now = globalNow;\n        } else {\n          throw new Error(\n            __DEV__\n              ? `The \\`now\\` parameter wasn't provided to \\`formatRelativeTime\\` and there was no global fallback configured on the provider.`\n              : undefined\n          );\n        }\n      }\n\n      const dateDate = date instanceof Date ? date : new Date(date);\n      const nowDate = now instanceof Date ? now : new Date(now);\n\n      const seconds = (dateDate.getTime() - nowDate.getTime()) / 1000;\n      const {unit, value} = getRelativeTimeFormatConfig(seconds);\n\n      return new Intl.RelativeTimeFormat(locale, {\n        numeric: 'auto'\n      }).format(value, unit);\n    } catch (error) {\n      onError(\n        new IntlError(IntlErrorCode.FORMATTING_ERROR, (error as Error).message)\n      );\n      return String(date);\n    }\n  }\n\n  return {formatDateTime, formatNumber, formatRelativeTime};\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useLocale() {\n  return useIntlContext().locale;\n}\n","import useIntlContext from './useIntlContext';\n\nexport default function useTimeZone() {\n  return useIntlContext().timeZone;\n}\n"],"names":["IntlErrorCode","IntlContext","createContext","undefined","defaultGetMessageFallback","namespace","key","filter","part","join","defaultOnError","error","console","IntlError","code","originalMessage","message","Error","setTimeZoneInFormats","formats","timeZone","Object","keys","reduce","acc","useIntlContext","context","useContext","resolvePath","messages","idPath","split","forEach","next","getNow","Date","children","onError","getMessageFallback","contextValues","React","Provider","value","locale","globalNow","now","getFormattedValue","formatOrOptions","typeFormats","formatter","options","MISSING_FORMAT","resolveFormatOrOptions","String","FORMATTING_ERROR","formatDateTime","dateTime","_options","Intl","DateTimeFormat","format","formatNumber","number","NumberFormat","formatRelativeTime","date","dateDate","nowDate","seconds","unit","absValue","Math","abs","round","MINUTE","HOUR","DAY","getRelativeTimeFormatConfig","getTime","RelativeTimeFormat","numeric","updateInterval","useState","setNow","useEffect","intervalId","setInterval","clearInterval","globalFormats","allMessages","cachedFormatsByLocaleRef","useRef","messagesOrError","useMemo","retrievedMessages","intlError","MISSING_MESSAGE","getFallbackFromErrorAndNotify","translateBaseFn","values","cachedFormatsByLocale","current","messageFormat","cacheKey","_cachedFormatsByLocal","INSUFFICIENT_PATH","IntlMessageFormat","formatsWithTimeZone","time","convertFormatsToIntlMessageFormat","INVALID_MESSAGE","formattedMessage","transformedValues","result","isValidElement","cloneElement","prepareTranslationValues","Array","isArray","translateFn","rich","raw"],"mappings":"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"}